% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/clonoStats.R
\name{clonoStats}
\alias{clonoStats}
\alias{clonoStats,SplitDataFrameList-method}
\alias{clonoStats,SingleCellExperiment-method}
\alias{clonoStats,clonoStats-method}
\title{Assign cell-level clonotypes and calculate abundances}
\usage{
clonoStats(x, ...)

\S4method{clonoStats}{SplitDataFrameList}(
  x,
  group = "sample",
  type = NULL,
  assignment = FALSE,
  method = "EM",
  lang = c("python", "r"),
  thresh = 0.01,
  iter.max = 1000
)

\S4method{clonoStats}{SingleCellExperiment}(x, contigs = "contigs", group = "sample", ...)

\S4method{clonoStats}{clonoStats}(x, group = NULL, lang = c("python", "r"))
}
\arguments{
\item{x}{A \code{SplitDataFrameList} object containing V(D)J contig
information, split by cell barcodes, as created by \code{readVDJcontigs}.
Alternatively, a \code{SingleCellExperiment} object with such a
\code{SplitDataFrameList} in the \code{colData}, as created by
\code{addVDJtoSCE}.}

\item{...}{additional arguments.}

\item{group}{The name of the column in \code{x} (or the \code{colData} of
\code{x}, for \code{SingleCellExperiment} objects) that stores each cell's
group identity, typically either its sample of origin or cluster label.
Alternatively, a vector of length equal to \code{x} (or \code{ncol(x)})
indicating the group identity. Providing this information can dramatically
speed up computation. When running \code{clonoStats} for the first time on
a dataset, we highly recommend setting the group identity to sample of
origin to avoid unwanted cross-talk between samples.}

\item{type}{The type of VDJ data (\code{"TCR"} or \code{"BCR"}). If
\code{NULL}, this is determined by the most prevalent \code{chain} types in
\code{x}.}

\item{assignment}{Logical, whether or not to return the full \code{nCells x
  nClonotypes} sparse matrix of clonotype assignments (default =
\code{FALSE})}

\item{method}{Which method to use for assigning cell-level clonotypes.
Options are \code{"EM"} (default), \code{"unique"}, or \code{"CellRanger"}.
Alternatively, this may be the name of a numeric column of \code{x} or any
\code{chain} type contained in \code{x}. See Details.}

\item{lang}{Indicates which implementation of certain methods to use. The EM
algorithm is implemented in both pure R (\code{'r'}) and mixed R and Python
(\code{'python'}, default) versions. Similarly, clonotype summarization is
implemented in two ways, which can impact speed, regardless of choice of
\code{method}.}

\item{thresh}{Numeric threshold for convergence of the EM algorithm.
Indicates the maximum allowable deviation in a count between updates. Only
used if \code{method = "EM"}.}

\item{iter.max}{Maximum number of iterations for the EM algorithm. Only used
if \code{method = "EM"}.}

\item{contigs}{The name of the column in the \code{colData} of \code{x} that
contains the VDJ contig data (only applies if \code{x} is a
\code{SingleCellExperiment}).}
}
\value{
Creates a sparse matrix (\code{dgRMatrix}) of cell-level clonotype
assignments (cells-by-clonotypes). If \code{x} is a
\code{SingleCellExperiment}, this matrix is added to the \code{colData}
under the name \code{clono}.
}
\description{
Assign clonotypes to cells and produce two summary tables: the
\code{clonotypes x samples} table of abundances and the \code{counts x
  samples} table of clonotype frequencies.
}
\details{
Assign each cell (with at least one V(D)J contig) to its most
likely clonotype with the EM algorithm. For ambiguous cells, this leads to
proportional (non-integer) assignment across multiple possible clonotypes.

This quantification method defines a clonotype as a pair of specific
chains (alpha and beta for T cells, heavy and light for B cells) and
attempts to assign each cell to its most likely clonotype. Unlike other
quantification methods, this can lead to non-integer counts for cells with
ambiguous information (ie. only an alpha chain, or two alphas and one beta
chain).

We highly recommend providing information on each cell's sample of
origin, as this can speed up computation and provide more accurate results.
Because the EM algorithm shares information across cells, splitting by
sample can improve accuracy by removing extraneous clonotypes from the set
of possibilities for a particular cell.
}
\examples{
data('contigs')
clonoStats(contigs)

}
